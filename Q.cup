import java_cup.runtime.*;
import ast.*;
import java.util.*;

terminal SEMICOLON, COMMA, DOT, COLON;
terminal LEFTBRACE, RIGHTBRACE;
terminal LEFTBRACKET, RIGHTBRACKET;
terminal LEFTTBRACKET, RIGHTTBRACKET;
terminal LEFTPAREN, RIGHTPAREN;

terminal BOOL, INT, FLOAT, STRING, LIST, CHAR, TUPLE, VOID;
terminal Boolean BOOLLITERAL;
terminal Integer INTLITERAL; terminal Float FLOATLITERAL;
terminal String STRINGLITERAL;
terminal Character CHARLITERAL;
terminal String ID;
terminal FDEF, TDEF;

terminal ASSIGN;
terminal NOT, OR, AND;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, POWER;
terminal IN, LENGTH, CONCAT;
terminal LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

terminal IF, ELSE, REPEAT, UNTIL, RETURN, DO, WHILE;

non terminal TypeNode type;
non terminal ExprNode expression;
non terminal FinalNode final;
non terminal TermNode term;
non terminal FactorNode factor;
non terminal ExponentNode exponent;
non terminal AccessorNode accessor;
non terminal SequenceNode sequence;
non terminal ListNode list;
non terminal TupleNode tuple;
non terminal ExprListNode expression_clist,expression_clist2;
non terminal VarDeclNode var_decl;
non terminal VarTypeNode var_type;
non terminal ExprListNode var_init;

non terminal TypeNode function_type;
non terminal FuncDeclNode function_decl;
non terminal ParamListNode parameter_clist, parameter_clist2;

non terminal DeclListNode global_decl_list, local_decl_list;
non terminal DeclNode global_decl;
non terminal DatatypeNode datatype_decl;

non terminal BlockNode block;
non terminal StatementListNode statement_list;
non terminal StmtNode statement;
non terminal IfElseNode ifelse;
non terminal RptUntilNode repeatuntil;
non terminal WhileStmtNode while;
non terminal AssignNode assignment;
non terminal FuncCallNode function_call;
non terminal ReturnStmtNode return;
non terminal ProgramNode program;

precedence right POWER;
precedence left DIVIDE, MULTIPLY;
precedence left PLUS, MINUS;

precedence nonassoc NOT;
precedence left OR, AND;
precedence right IN;
precedence nonassoc LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

start with program;

type ::= BOOL {: RESULT = new TypeNode("bool");:}
	| INT {: RESULT = new TypeNode("int");:}
	| FLOAT {: RESULT = new TypeNode("float");:}
	| STRING {: RESULT = new TypeNode("string");:}
	| CHAR {: RESULT = new TypeNode("char");:}
	| LIST {: RESULT = new TypeNode("list");:}
	| TUPLE {: RESULT = new TypeNode("tuple");:}
	| ID {: RESULT = new TypeNode("id");:}
;

program ::= 
global_decl_list:glbdecl block:blk {: RESULT = new ProgramNode(blk,glbdecl);System.out.println("Parsing Complete"); :}\
| block:blk {: new ProgramNode(blk,null);System.out.println("Parsing Complete"); :}
| error  {:System.out.print("Error");:}
;

global_decl_list ::= 
global_decl_list:declist global_decl:v 
{: if (declist != null) {
                       declist.declarations.add(v);
                       RESULT = declist;
                       
                   } else {
                       
                       RESULT = new DeclListNode(v);
                   }
                :}

| global_decl:v
{:
                       RESULT = new DeclListNode(v);
                   :}
;

global_decl ::= 
datatype_decl:datadecl 		{: RESULT = datadecl;:}
| var_decl:vardecl			{: RESULT = vardecl;:}
| function_decl	:funcdecl		{: RESULT = funcdecl;:}
;

function_decl ::= 
FDEF ID:id LEFTPAREN parameter_clist:paramlist RIGHTPAREN COLON function_type:ftype block:blk	{: RESULT = new FuncDeclNode(paramlist,id,ftype,blk);:}
;

var_type ::= 
ID:id COLON type:tp 	{: RESULT = new VarTypeNode(tp,id);:}
; 

var_decl ::= 
var_type:vtype var_init:vinit SEMICOLON {: RESULT = new VarDeclNode(vinit,vtype);:}
;

var_init ::=
ASSIGN expression_clist:elist	{: RESULT = elist;:}
|
;

datatype_decl ::=
TDEF ID:id COLON parameter_clist:parlist SEMICOLON	{: RESULT = new DatatypeNode(parlist,id);:}
;

function_type ::=
VOID 		{: RESULT = new TypeNode("void");:}
| type:t 	{: RESULT = t;:}
;

//two-productions are needed to avoid ambiguity
parameter_clist ::=
var_type:v parameter_clist2:parlist
{: if (parlist != null) {
                       parlist.params.add(v);
                       RESULT = new ParamListNode(parlist.params);
                       
                   } else {
                       ArrayList<VarTypeNode> res = new ArrayList<VarTypeNode>();
                       res.add(v);
                       RESULT = new ParamListNode(res);
                   }
                :}
| {: RESULT= null;:};

parameter_clist2 ::= 
COMMA var_type:v parameter_clist2:parlist
{: if (parlist != null) {
                       parlist.params.add(v);
                       RESULT = new ParamListNode(parlist.params);
                       
                   } else {
                       ArrayList<VarTypeNode> res = new ArrayList<VarTypeNode>();
                       res.add(v);
                       RESULT = new ParamListNode(res);
                   }
                :}
| {: RESULT = null;:};

block ::= 
LEFTBRACE local_decl_list:declist statement_list:stlist RIGHTBRACE {: RESULT = new BlockNode(stlist,declist);:}
| LEFTBRACE statement_list:stlist RIGHTBRACE					{: RESULT = new BlockNode(stlist,null);:}
;

// Local x only allows variable declarations
local_decl_list ::= 
local_decl_list:declist var_decl:v
{: if (declist != null) {
                       declist.declarations.add(v);
                       RESULT = declist;
                       
                   } else {
                       
                       RESULT = new DeclListNode(v);
                   }
                :}

| var_decl:v
{:
                       RESULT = new DeclListNode(v);
                   :}
;

statement_list ::=
statement:s statement_list:stlist
{: if (stlist != null) {
                       stlist.statements.add(s);
                       RESULT = new StatementListNode(stlist.statements);
                      
                   } else {
                       ArrayList<StmtNode> res = new ArrayList<StmtNode>();
                       res.add(s);
                       RESULT = new StatementListNode(res);
                   }
                :}
|{:RESULT = new StatementListNode(new ArrayList<StmtNode>());:};

statement ::= 
assignment:ass		{: RESULT = ass;:}
| function_call:func SEMICOLON	{: RESULT = new FuncCallStmtNode(func);:}	
| ifelse:ifel		{: RESULT = ifel;:}
| while:whi		{: RESULT = whi;:}
| repeatuntil:rptuntil	{: RESULT = rptuntil;:}
| return:ret		{: RESULT = ret;:}
;

ifelse ::= 
IF LEFTPAREN expression:e RIGHTPAREN LEFTBRACE statement_list:stlist1 RIGHTBRACE ELSE LEFTBRACE statement_list:stlist2 RIGHTBRACE	{: RESULT = new IfElseNode(e,stlist1,stlist2);:}
;

while ::=
WHILE LEFTPAREN expression:e RIGHTPAREN DO LEFTBRACE statement_list:stlist RIGHTBRACE	{: RESULT = new WhileStmtNode(e,stlist);:}
;

repeatuntil ::= 
REPEAT LEFTBRACE statement_list:stlist RIGHTBRACE UNTIL LEFTPAREN expression:e RIGHTPAREN SEMICOLON		{: RESULT = new RptUntilNode(e,stlist);:}
;

function_call ::=
ID:id LEFTPAREN expression_clist:elist RIGHTPAREN	{: RESULT = new FuncCallNode(elist,id);:}
;

return ::= 
RETURN expression:e SEMICOLON 	{: RESULT = new ReturnStmtNode(e);:}
| RETURN SEMICOLON		{: RESULT = new ReturnStmtNode(null);:}
;

assignment ::= 
accessor:acc ASSIGN expression:e SEMICOLON	{: RESULT = new AssignNode(e,acc);:}
;

sequence ::=
STRINGLITERAL:s		{: RESULT = new StringLitNode(s);:}
| tuple	:tup		{: RESULT = tup;:}
| list:lis		{: RESULT = lis;:}
;

accessor ::=
ID:d {: 
                   RESULT = new AccessorNode(d); :}
| accessor:acc DOT ID:d {:if(acc !=null) {
		acc.ids.add(d);
		RESULT = acc;
		}
		else
		{
                   RESULT = new AccessorNode(d);}
:}
;

tuple ::=
LEFTTBRACKET expression_clist:elist RIGHTTBRACKET		{: RESULT = new TupleNode(elist); :}
;

list ::= 
LEFTBRACKET expression_clist:elist RIGHTBRACKET 		{: RESULT = new ListNode(elist); :}
;

expression_clist ::= 
expression_clist:elist COMMA expression:e
{:         System.out.println("after here"+e);
		elist.expressions.add(e);
		RESULT = elist;
		:}
| 
expression:e	{: 
		if(e!=null)	
		 {System.out.println("after here2"+e);
                   RESULT = new ExprListNode(e); 
		}:}
|
;



expression ::=
term:t				{: RESULT = t; :}
| NOT expression:e		{: RESULT = new NotExprNode(e); :}
| expression:e PLUS term:t		{: RESULT = new PlusNode(e,t); :}
| expression:e MINUS term:t	{: RESULT = new MinusNode(e,t); :}
| expression:e OR term:t	{: RESULT = new OrNode(e,t); :}
| expression:e IN term:t	{: RESULT = new InNode(e,t); :}
| expression:e LESSTHAN term:t		{: RESULT = new LessThNode(e,t); :}
| expression:e LESSTHANEQUAL term:t	{: RESULT = new LessThEqNode(e,t); :}
| expression:e GREATERTHAN term:t		{: RESULT = new GreatThNode(e,t); :}
| expression:e GREATERTHANEQUAL term:t	{: RESULT = new GreatThEqNode(e,t); :}
| expression:e EQUAL term:t		{: RESULT = new EqNode(e,t); :}
| expression:e NOTEQUAL term:t		{: RESULT = new NotEqNode(e,t); :}
| expression:e CONCAT term:t		{: RESULT = new ConcatNode(e,t); :}
| expression:e1 LEFTBRACKET expression:e2 COLON expression:e3 RIGHTBRACKET	{: RESULT = new ThreeExprNode(e1,e2,e3); :}
| expression:e1 LEFTBRACKET expression:e2 COLON RIGHTBRACKET		{: RESULT = new EndColNode(e1,e2); :}
| expression:e1 LEFTBRACKET COLON expression:e2 RIGHTBRACKET		{: RESULT = new BegColNode(e1,e2); :}
| expression:e1 LEFTBRACKET expression:e2 RIGHTBRACKET		{: RESULT = new NoColNode(e1,e2); :}
;

term ::=
factor:fac		{: RESULT = fac; :}
| term:trm MULTIPLY factor:fac		{: RESULT = new MultiplyNode(trm,fac); :}
| term:trm DIVIDE factor:fac		{: RESULT = new DivideNode(trm,fac); :}	
| term:trm POWER factor:fac		{: RESULT = new PowerTermNode(trm,fac); :}
| term:trm AND factor:fac		{: RESULT = new AndNode(trm,fac); :}
;

factor ::=
exponent:exp POWER factor:fac	{: RESULT = new PowerNode(exp,fac); :}
| exponent:exp	{: RESULT = exp ;:}
;

exponent ::=
MINUS exponent:exp {: RESULT = new MinExponentNode(exp); :}
| final:fin {: RESULT = fin; :}
;

final ::=
accessor:acc	{: RESULT = acc; :}
| LEFTPAREN expression:e RIGHTPAREN  {: RESULT = new BrkExprNode(e); :}
| INTLITERAL:val	{: RESULT = new IntNode(val); :}
| FLOATLITERAL:val	{: RESULT = new FloatNode(val); :}
| BOOLLITERAL:val	{: RESULT = new BoolNode(val); :}
| CHARLITERAL:val	{: RESULT = new CharNode(val); :}
| function_call:func	{: RESULT = func;:}
| LENGTH LEFTPAREN expression:e RIGHTPAREN	{: RESULT = new LengthNode(e); :}
| sequence:seq // This includes STRINGLITERAL		{: RESULT = seq;:}
;
