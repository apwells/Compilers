import java_cup.runtime.*;

terminal SEMICOLON, COMMA, DOT, COLON;
terminal LEFTBRACE, RIGHTBRACE;
terminal LEFTBRACKET, RIGHTBRACKET;
terminal LEFTTBRACKET, RIGHTTBRACKET;
terminal LEFTPAREN, RIGHTPAREN;

terminal BOOL, INT, FLOAT, STRING, LIST, CHAR, TUPLE, VOID;
terminal ID, BOOLLITERAL, INTLITERAL, FLOATLITERAL, STRINGLITERAL, CHARLITERAL;

terminal FDEF, TDEF;

terminal ASSIGN;
terminal NOT, OR, AND;
terminal PLUS, MINUS, MULTIPLY, DIVIDE, POWER;
terminal IN, LENGTH, CONCAT;
terminal LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

terminal IF, ELSE, REPEAT, UNTIL, RETURN, DO, WHILE;

non terminal type;
non terminal expression, term, factor, exponent, final, accessor;
non terminal sequence, list, tuple;
non terminal expression_clist, expression_clist2;
non terminal var_decl, var_type, var_init;

non terminal function_type, function_decl;
non terminal parameter_clist, parameter_clist2;

non terminal global_decl_list, global_decl, local_decl_list;
non terminal datatype_decl;

non terminal block, statement_list, statement;
non terminal ifelse, repeatuntil, while, assignment, function_call, return;
non terminal program;

precedence right POWER;
precedence left DIVIDE, MULTIPLY;
precedence left PLUS, MINUS;

precedence nonassoc NOT;
precedence left OR, AND;
precedence right IN;
precedence nonassoc LESSTHAN, LESSTHANEQUAL, GREATERTHAN, GREATERTHANEQUAL, EQUAL, NOTEQUAL;

start with program;

type ::= BOOL {: RESULT = new TypeNode("bool");:}
	| INT {: RESULT = new TypeNode("int");:}
	| FLOAT {: RESULT = new TypeNode("float");:}
	| STRING {: RESULT = new TypeNode("string");:}
	| CHAR {: RESULT = new TypeNode("char");:}
	| LIST {: RESULT = new TypeNode("list");:}
	| TUPLE {: RESULT = new TypeNode("tuple");:}
	| ID {: RESULT = new TypeNode("id");:}
;

program ::= 
global_decl_list:glbdecl block:blk {: RESULT = new ProgramNode(blk,glbdecl);System.out.println("Parsing Complete"); :}
| block {: new ProgramNode(blk,null);System.out.println("Parsing Complete"); :}
;

global_decl_list ::= 
global_decl_list:declist global_decl:v 
{: if (declist != null) {
                       declist.declarations.add(v);
                       RESULT = new DeclListNode(decl.declarations);
                       
                   } else {
                       List<DeclNode> res = new ArrayList<DeclNode>();
                       res.add(v);
                       RESULT = new DeclListNode(res);
                   }
                :}

| global_decl:v
{
                       List<DeclNode> res = new ArrayList<DeclNode>();
                       res.add(v);
                       RESULT = new DeclListNode(res);
                   }
;

global_decl ::= 
datatype_decl:datadecl 		{: RESULT = datadecl;:}
| var_decl:vardecl			{: RESULT = vardecl;:}
| function_decl	:funcdecl		{: RESULT = funcdecl;:}
;

function_decl ::= 
FDEF ID:id LEFTPARENs parameter_clist:paramlist RIGHTPAREN COLON function_type:ftype block:blk	{: RESULT = new FuncDeclkNode(paramlist,id,ftype);:}
;

var_type ::= 
ID:id COLON type:tp 	{: RESULT = new VarTypeNode(tp,id);:}
; 

var_decl ::= 
var_type:vtype var_init:vinit SEMICOLON {: RESULT = new VarDeclNode(vinit,vtype);:}
;

var_init ::=
ASSIGN expression_clist:elist	{: RESULT = elist;:}
|
;

datatype_decl ::=
TDEF ID:id COLON parameter_clist:parlist SEMICOLON	{: RESULT = new DatatypeNode(parlist,id);:}
;

function_type ::=
VOID 		{: RESULT = new TypeNode("void");:}
| type:t 	{: RESULT = new TypeNode(t);:}
;

//two-productions are needed to avoid ambiguity
parameter_clist ::=
var_type:v parameter_clist2:parlist
{: if (parlist != null) {
                       parlist.params.add(v);
                       RESULT = new ParamListNode(parlist.params);
                       
                   } else {
                       List<VarTypeNode> res = new ArrayList<VarTypeNode>();
                       parlist.params.add(v);
                       RESULT = new ParamListNode(res);
                   }
                :}
| {: RESULT= null:};

parameter_clist2 ::= 
COMMA var_type:v parameter_clist2:parlist
{: if (parlist != null) {
                       parlist.params.add(v);
                       RESULT = new ParamListNode(parlist.params);
                       
                   } else {
                       List<VarTypeNode> res = new ArrayList<VarTypeNode>();
                       parlist.params.add(v);
                       RESULT = new ParamListNode(res);
                   }
                :}
| {: RESULT = null :};

block ::= 
LEFTBRACE local_decl_list:decllist statement_list:stlist RIGHTBRACE {: RESULT = new BlockNode(stlist,declist);:}
| LEFTBRACE statement_list RIGHTBRACE					{: RESULT = new BlockNode(stlist,null);:}
;

// Local x only allows variable declarations
local_decl_list ::= 
local_decl_list:declist var_decl:v
{: if (declist != null) {
                       declist.declarations.add(v);
                       RESULT = new DeclListNode(decl.declarations);
                       
                   } else {
                       List<DeclNode> res = new ArrayList<DeclNode>();
                       res.add(v);
                       RESULT = new DeclListNode(res);
                   }
                :}
| var_decl:v
{
                       List<DeclNode> res = new ArrayList<DeclNode>();
                       res.add(v);
                       RESULT = new DeclListNode(res);
                   }
;

statement_list ::=
statement:s statement_list:stlist
{: if (stlist != null) {
                       stlist.statements.add(s);
                       RESULT = new StatementListNode(stlist.statements);
                      
                   } else {
                       List<StmtNode> res = new ArrayList<StmtNode>();
                       res.add(s);
                       RESULT = new StatementListNode(res);
                   }
                :}
|{:RESULT = null;:};

statement ::= 
assignment:ass		{: RESULT = ass;:}
| function_call:func	{: RESULT = func;:}	
| ifelse:ifel		{: RESULT = ifel;:}
| while:who		{: RESULT = whi;:}
| repeatuntil:rptuntil	{: RESULT = rptuntil;:}
| return:ret		{: RESULT = ret;:}
;

ifelse ::= 
IF LEFTPAREN expression:e RIGHTPAREN LEFTBRACE statement_list:stlist1 RIGHTBRACE ELSE LEFTBRACE statement_list:stlist2 RIGHTBRACE	{: RESULT = new IfElseNode(e,stlist1,stlist2);:}
;

while ::=
WHILE LEFTPAREN expression:e RIGHTPAREN DO LEFTBRACE statement_list:stlist RIGHTBRACE	{: RESULT = new WhileStmtNode(e,stlist);:}
;

repeatuntil ::= 
REPEAT LEFTBRACE statement_list:stlist RIGHTBRACE UNTIL LEFTPAREN expression:e RIGHTPAREN SEMICOLON		{: RESULT = new RptUntilNode(e,stlist);:}
;

function_call ::=
ID:id LEFTPAREN expression_clist:elist RIGHTPAREN	{: RESULT = new FuncCallStmtNode(elist,id);:}
;

return ::= 
RETURN expression:e SEMICOLON 	{: RESULT = new ReturnStmtNode(e);:}
| RETURN SEMICOLON		{: RESULT = new ReturnStmtNode(null);:}
;

assignment ::= 
accessor:acc ASSIGN expression:e SEMICOLON	{: RESULT = new AssignNode(e,acc);:}
;

sequence ::=
STRINGLITERAL:s		{: RESULT = new StringLitNode(s);:}
| tuple	:tup		{: RESULT = tup;:}
| list:list		{: RESULT = lis;:}
;

accessor ::=
ID:d {: List<String> res = new ArrayList<String>();
                   res.add(d);
                   RESULT = new AccessorNode(res); :}
| accessor:acc DOT ID:id {:if(acc !=null) {
		acc.ids.add(id);
		RESULT = new AccessortNode(acc.ids);
		}
		else
		{List<ExprNode> res = new ArrayList<ExprNode>();
                   res.add(e);
                   RESULT = new AccessorNode(res);}
:}
;

tuple ::=
LEFTTBRACKET expression_clist:elist RIGHTTBRACKET		{: RESULT = new TupleNode(elist); :}
;

list ::= 
LEFTBRACKET expression_clist:elist RIGHTBRACKET 		{: RESULT = new ListNode(elist); :}
;

expression_clist ::= 
expression:e expression_clist2:elist
{:if(elist !=null) {
		elist.expressions.add(e);
		RESULT = new ExprListNode(elist.expressions);
		}
		else
		{List<ExprNode> res = new ArrayList<ExprNode>();
                   res.add(e);
                   RESULT = new ExprListNode(res);} :}
| expression_clist2:elist2 {: RESULT = elist2;:}
;

expression_clist2 ::= 
COMMA expression:e expression_clist2:elist
{:elist.expressions.add(e); RESULT = new ExprListNode(elist.expressions);:}
| {: RESULT = null;:}	
;

expression ::=
term:t				{: RESULT = t; :}
| NOT expression:e		{: RESULT = new NotExprNode(e); :}
| expression:e PLUS term:t		{: RESULT = new PlusNode(e,t); :}
| expression:e MINUS term:t	{: RESULT = new MinusNode(e,t); :}
| expression:e OR term:t	{: RESULT = new OrNode(e,t); :}
| expression:e IN term:t	{: RESULT = new InNode(e,t); :}
| expression:e LESSTHAN term:t		{: RESULT = new LessThNode(e,t); :}
| expression:e LESSTHANEQUAL term:t	{: RESULT = new LessThEqNode(e,t); :}
| expression:e GREATERTHAN term:t		{: RESULT = new GreatThNode(e,t); :}
| expression:e GREATERTHANEQUAL term:t	{: RESULT = new GreatThEqNode(e,t); :}
| expression:e EQUAL term:t		{: RESULT = new EqNode(e,t); :}
| expression:e NOTEQUAL term:t		{: RESULT = new NotEqNode(e,t); :}
| expression:e CONCAT term:t		{: RESULT = new ConcatNode(e,t); :}
| expression:e1 LEFTBRACKET expression:e2 COLON expression:e3 RIGHTBRACKET	{: RESULT = new ThreeExprNode(e1,e2,e3); :}
| expression:e1 LEFTBRACKET expression:e2 COLON RIGHTBRACKET		{: RESULT = new EndColNode(e1,e2); :}
| expression:e1 LEFTBRACKET COLON expression:e2 RIGHTBRACKET		{: RESULT = new BegColNode(e1,e2); :}
| expression:e1 LEFTBRACKET expression:e2 RIGHTBRACKET		{: RESULT = new NoColNode(e1,e2); :}
;

term ::=
factor:fac		{: RESULT = fac; :}
| term:trm MULTIPLY factor:fac		{: RESULT = new MultiplyNode(trm,fac); :}
| term:trm DIVIDE factor:fac		{: RESULT = new DivideNode(trm,fac); :}	
| term:trm POWER factor:fac		{: RESULT = new PowerTermNode(trm,fac); :}
| term:trm AND factor:fac		{: RESULT = new AndNode(trm,fac); :}
;

factor ::=
exponent:exp POWER factor:fac	{: RESULT = new PowerNode(exp,fac); :}
| exponent:exp	{: RESULT = exp :}
;

exponent ::=
MINUS exponent:exp {: RESULT = new MinExponentNode(exp); :}
| final:fin {: RESULT = fin; :}
;

final ::=
accessor:acc	{: RESULT = acc; :}
| LEFTPAREN expression:e RIGHTPAREN  {: RESULT = e; :}
| INTLITERAL:val	{: RESULT = new IntNode(val); :}
| FLOATLITERAL:val	{: RESULT = new FloatNode(val); :}
| BOOLLITERAL:val	{: RESULT = new BoolNode(val); :}
| CHARLITERAL:val	{: RESULT = new CharNode(val); :}
| function_call:func	{: RESULT = func;:}
| LENGTH LEFTPAREN expression:e RIGHTPAREN	{: RESULT = new LengthNode(e); :}
| sequence:seq // This includes STRINGLITERAL		{: RESULT = seq;:}
;
